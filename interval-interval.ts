/**
 * Algorithms are modified copies / ports / derivatives of Boost Interval Library which has the following license:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */



import { IntervalNumber } from './interval-number';
import { div_non_zero, div_negative, div_positive, div_zero } from './interval-utility';

export class Interval {

  protected start: number;
  protected end: number;

  protected _hasInnerBounds = false;

  /**
   * Expected inputs include all real numbers, Infinity, -Infinity
   */
  constructor( start: number, end?: number ) {

    if ( start > end || start === Infinity || end === -Infinity) {
      const swap: number = start;
      start = end;
      end = swap;
    }

    if ( end === undefined || end === null ) {
      end = start;
    }

    this.start = start;
    this.end = end;

  }

  /**
   * Returns the boolean set during division specifying that the interval is a wrap around matrix.
   */
  hasInnerBounds(): boolean {
    return this._hasInnerBounds;
  }

  /**
   * Produces a string representation of the interval, used extensively in tests to compare to
   * the boost interval lib results.
   */
  toString(): string {
    let rStr = '';

    if ( this.start === Infinity ) { rStr += 'inf';
    } else if ( this.start === -Infinity ) { rStr += '-inf';
    } else if ( this.start.toString() === 'NaN' ) { rStr += 'nan';
    } else { rStr += this.start; }

    rStr += ',';

    if ( this.end === Infinity ) { rStr += 'inf';
    } else if ( this.end === -Infinity ) { rStr += '-inf';
    } else if ( this.end.toString() === 'NaN' ) { rStr += 'nan';
    } else { rStr += this.end; }

    return rStr;
    // return '[' + this.start + ',' + this.end + ']';
  }

  /**
   * Returns the start, or lower bound
   */
  getStart(): number {
    return this.start;
  }

  /**
   * Returns the end, or upper bound
   */
  getEnd(): number {
    return this.end;
  }

  /**
   * Returns the start, or lower bound
   */
  getLower(): number {
    return this.start;
  }

  /**
   * Returns the end, or upper bound
   */
  getUpper(): number {
    return this.end;
  }



  /**
   * Adds a constant from this interval or adds this interval to another interval, returning the result as an array.
   */
  add ( ii: Interval | Array<Interval> | number | IntervalNumber ): Array<Interval> {

    const rarray: Array<Interval> = new Array<Interval>();

    if ( ii instanceof IntervalNumber || typeof(ii) === 'number' ) {

      let constant: number;

      if ( ii instanceof IntervalNumber ) {
        constant = ii.getConstant();
      } else {
        constant = ii;
      }

      rarray.push( new Interval( this.start + constant, this.end + constant ) );

    } else if ( ii instanceof Interval ) {

      rarray.push( new Interval( this.start + ii.start, this.end + ii.end ) );

    } else {

      ii.forEach ( i => { rarray.push( new Interval( this.start + i.start, this.end + i.end ) ); } );

    }

    return rarray;
  }

  /**
   * Subtracts a constant from this interval or subtracts another interval from this interval, returning the result as an array.
   */
  subtract ( ii: Interval | Array<Interval> | number | IntervalNumber ): Array<Interval> {

    const rarray: Array<Interval> = new Array<Interval>();

    if ( ii instanceof IntervalNumber || typeof(ii) === 'number' ) {

      let constant: number;

      if ( ii instanceof IntervalNumber ) {
        constant = ii.getConstant();
      } else {
        constant = ii;
      }

      rarray.push( new Interval( this.start - constant, this.end - constant ) );

    } else if ( ii instanceof Interval ) {

      rarray.push( new Interval( this.start - ii.end, this.end - ii.start ) );

    } else {

      ii.forEach ( i => { rarray.push( new Interval( this.start - i.end, this.end - i.start ) ); } );

    }

    return rarray;

  }

  /**
   * Private internal multiply implementation.
   */
  private _multiply ( ii: Interval ): Interval {

    // template<class T, class Policies> inline
    // interval<T, Policies> operator*(const interval<T, Policies>& x,
    //                                const interval<T, Policies>& y)
    // {
    //  BOOST_USING_STD_MIN();
    //  BOOST_USING_STD_MAX();
    //  typedef interval<T, Policies> I;
    //  if (interval_lib::detail::test_input(x, y))
    //    return I::empty();
    //  typename Policies::rounding rnd;
    //  const T& xl = x.lower();
    //  const T& xu = x.upper();
    //  const T& yl = y.lower();
    //  const T& yu = y.upper();

    const xl = this.start;
    const xu = this.end;
    const yl = ii.getStart();
    const yu = ii.getEnd();

    //  if (interval_lib::user::is_neg(xl))
    //    if (interval_lib::user::is_pos(xu))
    //      if (interval_lib::user::is_neg(yl))
    //        if (interval_lib::user::is_pos(yu)) // M * M
    //          return I(min BOOST_PREVENT_MACRO_SUBSTITUTION(rnd.mul_down(xl, yu), rnd.mul_down(xu, yl)),
    //                   max BOOST_PREVENT_MACRO_SUBSTITUTION(rnd.mul_up  (xl, yl), rnd.mul_up  (xu, yu)), true);
    //        else                    // M * N
    //          return I(rnd.mul_down(xu, yl), rnd.mul_up(xl, yl), true);
    //      else
    //        if (interval_lib::user::is_pos(yu)) // M * P
    //          return I(rnd.mul_down(xl, yu), rnd.mul_up(xu, yu), true);
    //        else                    // M * Z
    //          return I(static_cast<T>(0), static_cast<T>(0), true);

    if ( xl < 0 ) {
      if ( xu > 0 ) {
        if ( yl < 0 ) {
          if ( yu > 0 ) {
            return( new Interval(
              Math.min( xl * yu, xu * yl ),
              Math.max( xl * yl, xu * yu )
            ) );
          } else {
            return( new Interval(
              xu * yl,
              xl * yl
            ) );
          }
        } else {
          if ( yu > 0 ) {
            return( new Interval(
              xl * yu,
              xu * yu
            ) );
          } else {
            return( new Interval(
              0,
              0
            ) );
          }
        }

      //    else
      //      if (interval_lib::user::is_neg(yl))
      //        if (interval_lib::user::is_pos(yu)) // N * M
      //          return I(rnd.mul_down(xl, yu), rnd.mul_up(xl, yl), true);
      //        else                    // N * N
      //          return I(rnd.mul_down(xu, yu), rnd.mul_up(xl, yl), true);
      //      else
      //        if (interval_lib::user::is_pos(yu)) // N * P
      //          return I(rnd.mul_down(xl, yu), rnd.mul_up(xu, yl), true);
      //        else                    // N * Z
      //          return I(static_cast<T>(0), static_cast<T>(0), true);

      } else {
        if ( yl < 0 ) {
          if ( yu > 0 ) {
            return( new Interval(
              xl * yu,
              xl * yl
            ));
          } else {
            return( new Interval(
              xu * yu,
              xl * yl
            ));
          }
        } else {
          if ( yu > 0 ) {
            return( new Interval(
              xl * yu,
              xu * yl
            ));
          } else {
            return( new Interval(
              0,
              0
            ));
          }
        }
      }

    //  else
    //    if (interval_lib::user::is_pos(xu))
    //      if (interval_lib::user::is_neg(yl))
    //        if (interval_lib::user::is_pos(yu)) // P * M
    //          return I(rnd.mul_down(xu, yl), rnd.mul_up(xu, yu), true);
    //        else                    // P * N
    //          return I(rnd.mul_down(xu, yl), rnd.mul_up(xl, yu), true);
    //      else
    //        if (interval_lib::user::is_pos(yu)) // P * P
    //          return I(rnd.mul_down(xl, yl), rnd.mul_up(xu, yu), true);
    //        else                    // P * Z
    //          return I(static_cast<T>(0), static_cast<T>(0), true);
    //    else                        // Z * ?
    //      return I(static_cast<T>(0), static_cast<T>(0), true);

    } else {
      if ( xu > 0 ) {
        if ( yl < 0 ) {
          if ( yu > 0 ) {
            return( new Interval(
              xu * yl,
              xu * yu
            ));
          } else {
            return( new Interval(
              xu * yl,
              xl * yu
            ));
          }
        } else {
          if ( yu > 0 ) {
            return( new Interval(
              xl * yl,
              xu * yu
            ));
          } else {
            return( new Interval(
              0,
              0
            ));
          }
        }
      } else {
        return( new Interval(
          0,
          0
        ));
      }
    }
  }

  /**
   * Multiplies a constant to this interval or multiplies another interval to this interval, returning the result as an array.
   */
  multiply ( ii: Interval | Array<Interval> | number | IntervalNumber ): Array<Interval> {

    const rarray: Array<Interval> = new Array<Interval>();

    if ( ii instanceof IntervalNumber || typeof(ii) === 'number' ) {

      let constant: number;

      if ( ii instanceof IntervalNumber ) {
        constant = ii.getConstant();
      } else {
        constant = ii;
      }

      // template<class T, class Policies> inline
      // interval<T, Policies> operator*(const T& x, const interval<T, Policies>& y)
      // {
      //  typedef interval<T, Policies> I;
      //  if (interval_lib::detail::test_input(x, y))
      //    return I::empty();
      //  typename Policies::rounding rnd;
      //  const T& yl = y.lower();
      //  const T& yu = y.upper();
      //  // x is supposed not to be infinite
      //  if (interval_lib::user::is_neg(x))
      //    return I(rnd.mul_down(x, yu), rnd.mul_up(x, yl), true);
      //  else if (interval_lib::user::is_zero(x))
      //    return I(static_cast<T>(0), static_cast<T>(0), true);
      //  else
      //    return I(rnd.mul_down(x, yl), rnd.mul_up(x, yu), true);
      // }

      if ( constant < 0 ) {
        rarray.push( new Interval( constant * this.end, constant * this.start ) );
      } else if ( constant === 0 ) {
        rarray.push( new Interval( 0, 0 ) );
      } else {
        rarray.push( new Interval( constant * this.start, constant * this.end ) );
      }

    } else if ( ii instanceof Interval ) {

      rarray.push(this._multiply( ii ) );

    } else {

      ii.forEach ( i => { rarray.push(this._multiply( i ) ); } );

    }

    return rarray;

  }


  /**
   * Private internal divide implementation.
   */
  private _divide ( ii: Interval ): Interval {

    //    template<class T, class Policies> inline
    // interval<T, Policies> operator/(const interval<T, Policies>& x,
    //                                const interval<T, Policies>& y)
    // {
    //  if (interval_lib::detail::test_input(x, y))
    //    return interval<T, Policies>::empty();
    //  if (zero_in(y))
    //    if (!interval_lib::user::is_zero(y.lower()))
    //      if (!interval_lib::user::is_zero(y.upper()))
    //        return interval_lib::detail::div_zero(x);
    //      else
    //        return interval_lib::detail::div_negative(x, y.lower());
    //    else
    //      if (!interval_lib::user::is_zero(y.upper()))
    //        return interval_lib::detail::div_positive(x, y.upper());
    //      else
    //        return interval<T, Policies>::empty();
    //  else
    //    return interval_lib::detail::div_non_zero(x, y);
    // }

    if ( ( this.end < 0 && ii.start < 0 && 0 < ii.end ) || ( 0 < this.start && ii.start < 0 && 0 < ii.end ) ) {
      this._hasInnerBounds = true;
    } else {
      this._hasInnerBounds = false;
    }

    if ( ii.hasZero() ) {
      if ( ! ( ii.start === 0 ) ) {
        if ( ! ( ii.end === 0 ) ) {
          return( div_zero( this ) );
        } else {
          return( div_negative( this, ii.start ) );
        }
      } else {
        if ( ! ( ii.end === 0 ) ) {
          return( div_positive( this, ii.end ) );
        } else {
          return( new Interval ( Number.NaN, Number.NaN ) );
        }
      }
    } else {
      return( div_non_zero ( this, ii ) );
    }

  }

  /**
   * Divides a constant from this interval or divides another interval from this interval
   */
  divide ( ii: Interval | Array<Interval> | number | IntervalNumber ): Array<Interval> {
    // 〈 a,b 〉∗〈 1/d, 1/c 〉 http://fab.cba.mit.edu/classes/S62.12/docs/Hickey_interval.pdf

    const rarray: Array<Interval> = new Array<Interval>();

    if ( typeof(ii) === 'number' || ii instanceof IntervalNumber ) {

      let constant: number;

      if ( ii instanceof IntervalNumber ) {
        constant = ii.getConstant();
      } else {
        constant = ii;
      }

      // template<class T, class Policies> inline
      // interval<T, Policies> operator/(const interval<T, Policies>& x, const T& y)
      // {
      //  if (interval_lib::detail::test_input(x, y) || interval_lib::user::is_zero(y))
      //    return interval<T, Policies>::empty();
      //  typename Policies::rounding rnd;
      //  const T& xl = x.lower();
      //  const T& xu = x.upper();
      //  if (interval_lib::user::is_neg(y))
      //    return interval<T, Policies>(rnd.div_down(xu, y), rnd.div_up(xl, y), true);
      //  else
      //    return interval<T, Policies>(rnd.div_down(xl, y), rnd.div_up(xu, y), true);
      // }

      if ( constant === 0 ) {
        rarray.push ( new Interval ( -Number.NaN, Number.NaN ) );
      } else if ( constant < 0 ) {
        rarray.push ( new Interval ( this.end / constant, this.start / constant ) );
      } else {
        rarray.push ( new Interval ( this.start / constant, this.end / constant ) );
      }

    } else if ( ii instanceof Interval ) {

      rarray.push( this._divide( ii ) );

    } else {

      ii.forEach( i => { rarray.push( this._divide( i ) ); } );

    }

    return ( rarray );

  }

  /**
   * Returns the two wrap around intervals as an array
   */
  wrapAroundInterval( ii: Interval ): Array<Interval> {

    const rarray: Array<Interval> = new Array<Interval>();

    if ( ( this.end < 0 && ii.start < 0 && 0 < ii.end ) ) { // -2,-1 / -2,1

      rarray.push( new Interval( -Infinity, this.end / ii.end ) );
      rarray.push( new Interval( this.end / ii.start, Infinity ) );

    } else if ( ( 0 < this.start && ii.start < 0 && 0 < ii.end ) ) { // 1,2 / -1,1

      rarray.push( new Interval( -Infinity, this.start / ii.start ) );
      rarray.push( new Interval( this.start / ii.end, Infinity ) );

    } else {

      throw Error( 'Interval division does not create a wrap-around interval.' );

    }
    return rarray;

  }

  /**
   * Returns the inverse of the interval - this is incorrect
   */
  inverse (): Interval {

    if ( this.start === 0 || this.end === 0 ) {
      throw Error('Divide by 0 error.');
    }

    return new Interval ( 1 / this.end, 1 / this.start );

  }

  /**
   * Returns true if the interval contains 0 exclusively
   */
  hasZero ( ): boolean {
    return !( ( this.start > 0 && this.end > 0 ) || ( this.start < 0 && this.end < 0 ) );
  }

}








